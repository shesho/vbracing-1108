# Decentralized Dev Notes - Product Requirements Document

## Vision
Create a decentralized developer notes system inspired by John Carmack's development logs from the 80s-90s. Each developer maintains their own blog with standardized API endpoints, enabling a federated community of development notes.

## Project Overview
Two-phase implementation:
1. **Personal Dev Notes Blog** - Individual blog with API endpoints
2. **Community Client** - Aggregator to consume all participants' dev notes

---

## Architecture & Implementation

### Recommended Tech Stack

#### Phase 1: Next.js with Static Export
- **Framework**: Next.js 14+ (App Router with Static Export)
- **Deployment**: Vercel (zero-config deployment)
- **Styling**: Plain CSS (minimal, no framework needed)
- **Markdown**: gray-matter + react-markdown
- **Alternative**: Plain HTML/CSS if you prefer maximum simplicity

**Why Next.js Static Export:**
- Generates pure static files (HTML/JSON/MD) - zero server costs
- All endpoints are pre-rendered static files in `public/`
- Maximum reliability and performance
- One-command Vercel deployment
- File-based routing with SSG

#### Phase 2: Next.js or React/Vue SPA
- **Framework**: Next.js, React, or Vue
- **State Management**: React Context or local state
- **Deployment**: Vercel or local

---

### Project Structure (Phase 1)

```
dev-notes-blog/
├── app/
│   ├── page.tsx                    # Homepage (list view)
│   ├── notes/
│   │   └── [slug]/
│   │       └── page.tsx            # Individual note detail page
│   ├── layout.tsx                  # Layout with vintage styling
│   └── globals.css                 # Vintage terminal styles
├── public/
│   └── api/
│       ├── metadata.json           # ⭐ ENDPOINT 1: Profile metadata
│       ├── files.json              # ⭐ ENDPOINT 2: Auto-generated list
│       └── notes/
│           ├── first-note.md       # ⭐ ENDPOINT 3: Individual notes
│           ├── second-note.md
│           └── ...
├── content/
│   └── notes/
│       ├── first-note.md           # Source markdown files
│       ├── second-note.md
│       └── ...
├── scripts/
│   └── generate-api.js             # Script to generate files.json
├── lib/
│   └── notes.ts                    # Helper functions to read notes
├── next.config.js                  # Static export configuration
├── vercel.json                     # CORS and MIME type headers
├── package.json
└── README.md
```

**Key Points:**
- ⭐ **All endpoints live in `public/api/`** - easy to identify
- Source notes in `content/notes/` (for editing)
- Build script copies notes to `public/api/notes/` and generates `files.json`
- Static files = fast, cheap, reliable

---

### Endpoint Implementation Details

#### Endpoint 1: `/api/metadata.json`
**Location:** `public/api/metadata.json`

**Implementation:**
- Manually create this file with your profile info
- Static JSON file
- Edit directly when profile changes
- Automatically served by Next.js static export

**Example:**
```json
{
  "version": "1.0.0",
  "profile": {
    "name": "Your Name",
    "avatar": "https://github.com/yourusername.png",
    "contact": {
      "github": "yourusername",
      "linkedin": "https://linkedin.com/in/yourusername",
      "email": "you@example.com"
    }
  },
  "fileList": {
    "url": "https://yourdomain.vercel.app/api/files.json",
    "format": "json",
    "lastUpdated": "2025-11-08T10:00:00Z"
  }
}
```

#### Endpoint 2: `/api/files.json`
**Location:** `public/api/files.json` (auto-generated)

**Implementation:**
- Generated by build script from `content/notes/` directory
- Reads frontmatter from all markdown files
- Creates JSON list with required fields
- Run script before deployment

**Build Script** (`scripts/generate-api.js`):
```javascript
const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

const CONTENT_DIR = path.join(__dirname, '../content/notes');
const OUTPUT_DIR = path.join(__dirname, '../public/api/notes');
const FILES_JSON = path.join(__dirname, '../public/api/files.json');
const METADATA_JSON = path.join(__dirname, '../public/api/metadata.json');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Ensure content directory exists
if (!fs.existsSync(CONTENT_DIR)) {
  console.error(`❌ Error: content/notes/ directory not found. Please create it and add some notes.`);
  process.exit(1);
}

// Read metadata to derive base URL
let baseUrl = process.env.NEXT_PUBLIC_SITE_URL || process.env.VERCEL_URL;
if (!baseUrl && fs.existsSync(METADATA_JSON)) {
  try {
    const metadata = JSON.parse(fs.readFileSync(METADATA_JSON, 'utf8'));
    baseUrl = metadata.fileList.url.replace('/api/files.json', '');
  } catch (err) {
    console.warn('⚠️  Warning: Could not read metadata.json to derive base URL');
  }
}

// Add https:// prefix for VERCEL_URL if needed
if (baseUrl && !baseUrl.startsWith('http')) {
  baseUrl = `https://${baseUrl}`;
}

if (!baseUrl) {
  console.error(`❌ Error: Cannot determine base URL. Please either:
  1. Set NEXT_PUBLIC_SITE_URL environment variable, or
  2. Ensure public/api/metadata.json exists with valid fileList.url`);
  process.exit(1);
}

// Read all markdown files
const files = fs.readdirSync(CONTENT_DIR).filter(f => f.endsWith('.md'));

if (files.length === 0) {
  console.warn('⚠️  Warning: No markdown files found in content/notes/');
}

const notes = files.map(file => {
  const filePath = path.join(CONTENT_DIR, file);
  const content = fs.readFileSync(filePath, 'utf8');

  let data;
  try {
    ({ data } = matter(content));
  } catch (err) {
    console.error(`❌ Error parsing frontmatter in ${file}:`, err.message);
    process.exit(1);
  }

  // Validate required fields
  if (!data.title) {
    console.error(`❌ Error: Missing required field 'title' in ${file}`);
    process.exit(1);
  }
  if (!data.date) {
    console.error(`❌ Error: Missing required field 'date' in ${file}`);
    process.exit(1);
  }

  // Validate date format (ISO 8601)
  if (isNaN(Date.parse(data.date))) {
    console.error(`❌ Error: Invalid date format in ${file}. Use ISO 8601: "2025-11-08T10:00:00Z"`);
    process.exit(1);
  }

  const slug = file.replace('.md', '');

  // Copy to public/api/notes/
  fs.copyFileSync(filePath, path.join(OUTPUT_DIR, file));

  return {
    id: data.id || slug,
    title: data.title,
    slug: slug,
    date: data.date,
    excerpt: data.excerpt || '',
    url: `${baseUrl}/api/notes/${file}`,
    tags: data.tags || []
  };
}).sort((a, b) => new Date(b.date) - new Date(a.date));

// Write files.json
fs.writeFileSync(FILES_JSON, JSON.stringify({ notes }, null, 2));

// Update lastUpdated in metadata.json
if (fs.existsSync(METADATA_JSON)) {
  try {
    const metadata = JSON.parse(fs.readFileSync(METADATA_JSON, 'utf8'));
    metadata.fileList.lastUpdated = new Date().toISOString();
    fs.writeFileSync(METADATA_JSON, JSON.stringify(metadata, null, 2));
  } catch (err) {
    console.warn('⚠️  Warning: Could not update lastUpdated in metadata.json:', err.message);
  }
}

console.log(`✅ Generated files.json with ${notes.length} notes`);
console.log(`   Base URL: ${baseUrl}`);
```

**Example Output:**
```json
{
  "notes": [
    {
      "id": "001",
      "title": "Setting Up the Dev Blog",
      "slug": "setup-dev-blog",
      "date": "2025-11-08T10:00:00Z",
      "excerpt": "Initial setup of the decentralized dev notes blog",
      "url": "https://yourdomain.vercel.app/api/notes/setup-dev-blog.md",
      "tags": ["setup", "meta"]
    }
  ]
}
```

#### Endpoint 3: `/api/notes/[slug].md`
**Location:** `public/api/notes/*.md` (copied from content)

**Implementation:**
- Raw markdown files with frontmatter
- Served as `Content-Type: text/markdown`
- Copied from `content/notes/` during build
- Named by slug (e.g., `my-note.md`)

**Example File:**
```markdown
---
title: "Setting Up the Dev Blog"
date: "2025-11-08T10:00:00Z"
tags: ["setup", "meta"]
excerpt: "Initial setup of the decentralized dev notes blog"
---

# Setting Up the Dev Blog

Today I started building the decentralized dev notes blog...
```

---

### Simplified Workflow: Adding a New Note

1. **Create markdown file** in `content/notes/my-new-note.md`
2. **Add frontmatter** with required fields (title, date)
3. **Run build script**: `npm run build:api`
   - Generates `public/api/files.json`
   - Copies note to `public/api/notes/my-new-note.md`
   - Updates lastUpdated timestamp in metadata
4. **Commit and push** to GitHub
5. **Vercel auto-deploys** (or run `vercel deploy`)
6. **Done** - Note is live at all three endpoints

---

### Deployment to Vercel

#### Initial Setup
```bash
# Install Vercel CLI
npm i -g vercel

# Deploy from project root
vercel

# Follow prompts to link project
```

#### Automatic Deployment
- Connect GitHub repo to Vercel
- Every push to main branch auto-deploys
- Build command: `npm run build:api && next build`
- Output directory: `out/` (static export)

#### Package Configuration
Add to `package.json`:
```json
{
  "scripts": {
    "dev": "next dev",
    "build:api": "node scripts/generate-api.js",
    "build": "npm run build:api && next build",
    "start": "next start",
    "deploy": "vercel --prod"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-markdown": "^9.0.0",
    "gray-matter": "^4.0.3"
  }
}
```

#### Next.js Configuration (REQUIRED)
Create `next.config.js` to enable static export:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true // Required for static export
  }
}

module.exports = nextConfig
```

**Important:** Without this file, Next.js will not generate static files and deployment will fail.

#### Vercel Configuration (REQUIRED)
Create `vercel.json` for CORS and proper MIME types:
```json
{
  "headers": [
    {
      "source": "/api/notes/(.*).md",
      "headers": [
        { "key": "Content-Type", "value": "text/markdown; charset=utf-8" },
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "GET, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    },
    {
      "source": "/api/(.*).json",
      "headers": [
        { "key": "Content-Type", "value": "application/json; charset=utf-8" },
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "GET, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    }
  ]
}
```

**Important:** This ensures:
- Phase 2 clients can fetch your endpoints (CORS)
- Markdown files are served with correct MIME type
- JSON endpoints are properly typed

---

### Alternative: Plain HTML/CSS (Ultra-Simple)

If you prefer maximum simplicity without frameworks:

**Structure:**
```
dev-notes-blog/
├── index.html                      # List view
├── notes/
│   └── [slug].html                 # Detail pages
├── api/
│   ├── metadata.json              # Endpoint 1
│   ├── files.json                 # Endpoint 2 (manual)
│   └── notes/*.md                 # Endpoint 3
├── styles.css
└── build.sh                       # Optional: script to generate files.json
```

**Deployment:**
- Upload entire directory to Vercel
- Or use GitHub Pages
- No build step required if you manually maintain `files.json`

---

### Phase 2 Architecture (Client)

**Recommended Approach:**
```
dev-notes-client/
├── app/
│   ├── page.tsx                    # Feed view (all developers)
│   ├── developers/
│   │   └── [id]/page.tsx           # Individual developer view
│   └── settings/
│       └── page.tsx                # Manage metadata URLs
├── lib/
│   ├── registry.ts                 # List of developer metadata URLs
│   ├── aggregator.ts               # Fetch and merge notes
│   └── cache.ts                    # Simple cache mechanism
└── public/
    └── registry.json               # Community registry of developers
```

**Data Flow:**
1. Client loads `registry.json` with list of metadata URLs
2. Fetches each developer's `/api/metadata.json`
3. Fetches each developer's `/api/files.json`
4. Displays aggregated feed
5. Caches in localStorage (simple client-side cache)
6. Fetches individual notes on-demand

**Community Registry** (`public/registry.json`):
```json
{
  "developers": [
    {
      "name": "Developer 1",
      "metadataUrl": "https://dev1.vercel.app/api/metadata.json"
    },
    {
      "name": "Developer 2",
      "metadataUrl": "https://dev2.vercel.app/api/metadata.json"
    }
  ]
}
```

**Registry Management:**
- Hosted in a community GitHub repository
- Developers submit PRs to add their metadata URL
- Simple validation: metadata URL must be accessible and return valid JSON
- Merge PRs manually after basic validation

---

### Reference Implementation Files

Below are complete reference implementations for all Next.js components needed for Phase 1.

#### `lib/notes.ts` - Helper Functions
```typescript
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const notesDirectory = path.join(process.cwd(), 'content/notes');

export interface Note {
  slug: string;
  title: string;
  date: string;
  excerpt?: string;
  tags?: string[];
  content: string;
}

export function getAllNotes(): Note[] {
  const fileNames = fs.readdirSync(notesDirectory);
  const allNotes = fileNames
    .filter(fileName => fileName.endsWith('.md'))
    .map(fileName => {
      const slug = fileName.replace(/\.md$/, '');
      const fullPath = path.join(notesDirectory, fileName);
      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const { data, content } = matter(fileContents);

      return {
        slug,
        title: data.title,
        date: data.date,
        excerpt: data.excerpt,
        tags: data.tags,
        content
      };
    });

  return allNotes.sort((a, b) => (a.date < b.date ? 1 : -1));
}

export function getNoteBySlug(slug: string): Note | null {
  try {
    const fullPath = path.join(notesDirectory, `${slug}.md`);
    const fileContents = fs.readFileSync(fullPath, 'utf8');
    const { data, content } = matter(fileContents);

    return {
      slug,
      title: data.title,
      date: data.date,
      excerpt: data.excerpt,
      tags: data.tags,
      content
    };
  } catch {
    return null;
  }
}

export function getAllSlugs(): string[] {
  const fileNames = fs.readdirSync(notesDirectory);
  return fileNames
    .filter(fileName => fileName.endsWith('.md'))
    .map(fileName => fileName.replace(/\.md$/, ''));
}
```

#### `app/layout.tsx` - Root Layout
```typescript
import './globals.css';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Dev Notes',
  description: 'Decentralized developer notes inspired by John Carmack',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <div className="container">
          <header>
            <h1>{'>'} DEV.NOTES</h1>
            <p className="subtitle">A decentralized development log</p>
          </header>
          <main>{children}</main>
          <footer>
            <p>Part of the decentralized dev notes network</p>
          </footer>
        </div>
      </body>
    </html>
  );
}
```

#### `app/globals.css` - Vintage Terminal Styling
```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #0c0c0c;
  color: #00ff00;
  font-family: 'Courier New', Courier, monospace;
  line-height: 1.6;
  padding: 20px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
}

header {
  border-bottom: 2px solid #00ff00;
  padding-bottom: 20px;
  margin-bottom: 40px;
}

header h1 {
  font-size: 2rem;
  font-weight: bold;
  margin-bottom: 5px;
}

.subtitle {
  color: #00aa00;
  font-size: 0.9rem;
}

footer {
  margin-top: 60px;
  padding-top: 20px;
  border-top: 1px solid #00ff00;
  color: #00aa00;
  font-size: 0.85rem;
  text-align: center;
}

a {
  color: #00ff00;
  text-decoration: none;
  border-bottom: 1px dotted #00ff00;
}

a:hover {
  color: #00ff00;
  background: #003300;
}

.note-list {
  list-style: none;
}

.note-item {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #004400;
  background: #001100;
}

.note-item:hover {
  border-color: #00ff00;
}

.note-title {
  font-size: 1.3rem;
  margin-bottom: 5px;
}

.note-date {
  color: #00aa00;
  font-size: 0.85rem;
  margin-bottom: 10px;
}

.note-excerpt {
  color: #00cc00;
}

.note-tags {
  margin-top: 10px;
}

.tag {
  display: inline-block;
  background: #003300;
  color: #00ff00;
  padding: 2px 8px;
  margin-right: 5px;
  font-size: 0.75rem;
  border: 1px solid #004400;
}

.note-content {
  margin-top: 20px;
}

.note-content h1 {
  font-size: 1.8rem;
  margin-top: 30px;
  margin-bottom: 15px;
}

.note-content h2 {
  font-size: 1.4rem;
  margin-top: 25px;
  margin-bottom: 12px;
}

.note-content h3 {
  font-size: 1.2rem;
  margin-top: 20px;
  margin-bottom: 10px;
}

.note-content p {
  margin-bottom: 15px;
}

.note-content ul,
.note-content ol {
  margin-left: 30px;
  margin-bottom: 15px;
}

.note-content code {
  background: #001100;
  color: #00ff00;
  padding: 2px 6px;
  border: 1px solid #004400;
}

.note-content pre {
  background: #001100;
  color: #00ff00;
  padding: 15px;
  border: 1px solid #004400;
  overflow-x: auto;
  margin-bottom: 15px;
}

.note-content pre code {
  background: none;
  border: none;
  padding: 0;
}

.back-link {
  display: inline-block;
  margin-bottom: 20px;
  color: #00aa00;
}

.back-link:hover {
  color: #00ff00;
}

@media (max-width: 768px) {
  body {
    padding: 10px;
  }

  header h1 {
    font-size: 1.5rem;
  }

  .note-title {
    font-size: 1.1rem;
  }
}
```

#### `app/page.tsx` - Homepage List View
```typescript
import Link from 'next/link';
import { getAllNotes } from '@/lib/notes';

export default function HomePage() {
  const notes = getAllNotes();

  return (
    <div>
      <h2>Recent Notes [{notes.length}]</h2>
      <ul className="note-list">
        {notes.map(note => (
          <li key={note.slug} className="note-item">
            <Link href={`/notes/${note.slug}`}>
              <h3 className="note-title">{note.title}</h3>
            </Link>
            <div className="note-date">{new Date(note.date).toLocaleString()}</div>
            {note.excerpt && <p className="note-excerpt">{note.excerpt}</p>}
            {note.tags && note.tags.length > 0 && (
              <div className="note-tags">
                {note.tags.map(tag => (
                  <span key={tag} className="tag">
                    {tag}
                  </span>
                ))}
              </div>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### `app/notes/[slug]/page.tsx` - Individual Note Page
```typescript
import { notFound } from 'next/navigation';
import Link from 'next/link';
import ReactMarkdown from 'react-markdown';
import { getNoteBySlug, getAllSlugs } from '@/lib/notes';

export async function generateStaticParams() {
  const slugs = getAllSlugs();
  return slugs.map(slug => ({ slug }));
}

export default function NotePage({ params }: { params: { slug: string } }) {
  const note = getNoteBySlug(params.slug);

  if (!note) {
    notFound();
  }

  return (
    <article>
      <Link href="/" className="back-link">
        ← Back to notes
      </Link>
      <h1>{note.title}</h1>
      <div className="note-date">{new Date(note.date).toLocaleString()}</div>
      {note.tags && note.tags.length > 0 && (
        <div className="note-tags">
          {note.tags.map(tag => (
            <span key={tag} className="tag">
              {tag}
            </span>
          ))}
        </div>
      )}
      <div className="note-content">
        <ReactMarkdown>{note.content}</ReactMarkdown>
      </div>
    </article>
  );
}
```

---

## Phase 1: Personal Dev Notes Blog

### Core Requirements

#### 1. Blog Features
- **List View**: Display all dev notes chronologically
- **Detail View**: Individual note pages with full content
- **Markdown Support**: Notes written in Markdown with Frontmatter
- **Vintage Aesthetic**: Hacker-style minimal design (inspired by John Carmack's .plan files). Use monospaced fonts and a late 80-s theme.

#### 2. Required API Endpoints

##### Endpoint 1: Metadata (`/api/metadata.json`)
Returns JSON with profile information and file list location.

**Schema:**
```json
{
  "version": "1.0.0",
  "profile": {
    "name": "string (required)",
    "avatar": "string (URL)",
    "contact": {
      "github": "string",
      "linkedin": "string (URL)",
      "email": "string (email format)",
      "twitter": "string (@handle)",
      "website": "string (URL)",
      "other": [
        {
          "platform": "string (required)",
          "url": "string (URL, required)",
          "label": "string (optional)"
        }
      ]
    }
  },
  "fileList": {
    "url": "string (URL, required)",
    "format": "json",
    "lastUpdated": "string (ISO 8601 datetime)"
  }
}
```

##### Endpoint 2: File List (`/api/files.json`)
Returns list of all dev notes.

**Schema:**
```json
{
  "notes": [
    {
      "id": "string",
      "title": "string",
      "slug": "string",
      "date": "string (ISO 8601)",
      "excerpt": "string (optional)",
      "url": "string (URL to full note)",
      "tags": ["string"] (optional)
    }
  ]
}
```

##### Endpoint 3: Individual Note (`/api/notes/[slug].md`)
Returns Markdown file with Frontmatter.

**Format:**
```markdown
---
title: "Note Title"
date: "2025-11-08T10:30:00Z"
tags: ["tag1", "tag2"]
excerpt: "Short description"
---

# Note content in Markdown

Full content here...
```

#### 3. Minimum Content Requirement
- **5 dev notes** published by end of event
- Notes should document what you're building during the hackathon
- Follow terse, technical style (Carmack-inspired)

#### 4. Design Guidelines
- Vintage hacker aesthetic
- Minimal, text-focused interface
- Monospace fonts preferred
- Terminal-like color schemes (green on black, amber on black, etc.)
- Fast loading, no unnecessary JavaScript
- Mobile-responsive but desktop-first

---

## Phase 2: Community Dev Notes Client

### Purpose
Aggregate and display dev notes from all Hackathon participants in one interface.

### Core Features

#### 1. Multi-Source Aggregation
- Consume metadata endpoints from multiple developers
- Fetch and display notes from all sources
- Handle different blog implementations

#### 2. User Interface
- **Feed View**: Chronological stream of all notes from all developers
- **Developer Profiles**: Individual developer pages showing their notes
- **Filter/Search**: By developer, date, tags
- **Source Management**: Add/remove developer metadata URLs

#### 3. Technical Requirements
- Poll/fetch from metadata endpoints
- Cache notes locally
- Handle offline sources gracefully
- Display author information with each note
- Link back to original source

#### 4. Community Features
- Subscribe to specific developers
- Export/share aggregated feeds
- Potentially integrate with RbR website

---

## Technical Specifications

### Note Frontmatter Fields

**Required:**
```yaml
title: string (required)
date: ISO 8601 datetime (required)
```

**Optional:**
```yaml
id: string (optional - defaults to filename slug)
tags: array of strings (optional)
excerpt: string (optional)
```

**ID Generation Strategy:**
- If `id` field is present in frontmatter, use it
- If not, use filename without `.md` extension as ID/slug
- Keep filenames URL-safe: `my-note.md` → id: `my-note`
- Recommended: Let filename be the ID (simpler workflow)

### API Response Formats
- All endpoints return JSON except individual notes (Markdown)
- Use ISO 8601 for all datetime values
- All URLs must be absolute, not relative
- Support CORS for cross-origin requests

### Content Guidelines
- Notes should be technical, not promotional
- Focus on "what" and "why", not just "what"
- Include code snippets where relevant
- Keep individual notes focused (one topic per note)
- Carmack-style: bullet points, completed tasks, problems solved

---

## Deployment Requirements

### Phase 1 (Blog)
- Deploy to public URL
- All three endpoints must be accessible
- Share metadata URL in event chat
- SSL/HTTPS required
- Fast response times (<500ms per endpoint)

### Phase 2 (Client)
- Can be deployed or run locally
- Must handle multiple metadata sources
- Graceful error handling for unavailable sources

---

## Success Criteria

### Phase 1
- [ ] Blog deployed with public URL
- [ ] All 3 API endpoints functional and spec-compliant
- [ ] Metadata URL shared with community
- [ ] Minimum 5 notes published
- [ ] Vintage hacker aesthetic achieved
- [ ] Mobile responsive

### Phase 2
- [ ] Client can consume multiple metadata sources
- [ ] Displays aggregated notes from all participants
- [ ] Filter/search functionality works
- [ ] Handles errors gracefully
- [ ] Community can use for ongoing dev notes

---

## Architecture Decision Records

### Key Simplifications Made

1. **Format Field**: Changed from `json|xml|csv` to just `json`
   - **Rationale**: Reduces complexity, JSON is universal and well-supported
   - **Trade-off**: Slight reduction in flexibility, but no real-world impact

2. **Static Files in `public/api/`**: All endpoints are static files
   - **Rationale**: Fastest, cheapest, most reliable hosting
   - **Trade-off**: Need build script, but adds clarity and simplicity

3. **Build Script for Automation**: `generate-api.js` creates `files.json`
   - **Rationale**: Prevents manual maintenance errors, ensures consistency
   - **Trade-off**: Extra build step, but automated in deployment

4. **Next.js Recommended but Not Required**: Plain HTML/CSS alternative provided
   - **Rationale**: Next.js is easiest for Vercel, but not everyone wants a framework
   - **Trade-off**: Two approaches documented, pick what fits your style

5. **Community Registry**: Simple JSON file for Phase 2
   - **Rationale**: Decentralized discovery needs a starting point
   - **Trade-off**: Manual PR process, but creates community engagement

6. **ID/Slug Generation**: Filename becomes the slug (optional frontmatter override)
   - **Rationale**: Simpler workflow - just name the file correctly
   - **Trade-off**: Renaming files changes URLs, but frontmatter `id` allows override if needed

---

## Getting Started: Step-by-Step Setup

### Prerequisites
- Node.js 18+ installed
- GitHub account
- Vercel account (free tier)

### Step 1: Initialize Project

```bash
# Create project directory
mkdir my-dev-notes-blog
cd my-dev-notes-blog

# Initialize with Git
git init
echo "node_modules/" > .gitignore
echo ".next/" >> .gitignore
echo "out/" >> .gitignore
echo ".env*.local" >> .gitignore

# Initialize npm
npm init -y

# Install dependencies
npm install next@14 react react-dom react-markdown gray-matter

# Install dev dependencies
npm install -D @types/node @types/react @types/react-dom typescript

# Create directory structure
mkdir -p app/notes/[slug] content/notes public/api/notes scripts lib
```

### Step 2: Create Configuration Files

Create `next.config.js`:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true
  }
}

module.exports = nextConfig
```

Create `vercel.json`:
```json
{
  "headers": [
    {
      "source": "/api/notes/(.*).md",
      "headers": [
        { "key": "Content-Type", "value": "text/markdown; charset=utf-8" },
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "GET, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    },
    {
      "source": "/api/(.*).json",
      "headers": [
        { "key": "Content-Type", "value": "application/json; charset=utf-8" },
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "GET, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    }
  ]
}
```

Create `tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

### Step 3: Create Your Profile

Create `public/api/metadata.json` with your actual domain (you'll update this after first deployment):

```json
{
  "version": "1.0.0",
  "profile": {
    "name": "Your Name",
    "avatar": "https://github.com/yourusername.png",
    "contact": {
      "github": "yourusername",
      "linkedin": "https://linkedin.com/in/yourusername",
      "email": "you@example.com"
    }
  },
  "fileList": {
    "url": "https://YOUR-PROJECT.vercel.app/api/files.json",
    "format": "json",
    "lastUpdated": "2025-11-08T00:00:00Z"
  }
}
```

**Tips:**
- Use your GitHub profile pic: `https://github.com/USERNAME.png`
- Leave the URL as placeholder - it will be auto-derived from this metadata file by the build script
- Only include contact methods you want public

### Step 4: Create Implementation Files

Copy all reference implementation files from the "Reference Implementation Files" section above:
- `lib/notes.ts`
- `app/layout.tsx`
- `app/globals.css`
- `app/page.tsx`
- `app/notes/[slug]/page.tsx`

### Step 5: Create Build Script

Copy the complete build script from the "Build Script" section above into `scripts/generate-api.js`.

**Key features of the script:**
- Auto-derives base URL from `metadata.json` or `NEXT_PUBLIC_SITE_URL` environment variable
- Validates all required frontmatter fields
- Provides helpful error messages
- Updates `lastUpdated` timestamp automatically

### Step 6: Write Your First Note

Create `content/notes/first-note.md`:

```markdown
---
title: "Starting My Dev Notes Blog"
date: "2025-11-08T00:00:00Z"
tags: ["meta", "setup"]
excerpt: "Setting up my decentralized dev notes blog for Hackathon"
---

# Starting My Dev Notes Blog

Today I set up my dev notes blog inspired by John Carmack's .plan files.

## What I Did
- Initialized Next.js project
- Created API endpoints for metadata and notes
- Deployed to Vercel

## Next Steps
- Write more notes as I build
- Share metadata URL with community
- Reach 5 notes minimum

## Tech Stack
- Next.js 14
- Deployed on Vercel
- Markdown with gray-matter
```

**Note Naming Convention:**
- Use kebab-case: `my-note-title.md`
- Filename becomes the slug
- Keep filenames URL-friendly (no spaces, special chars)

### Step 7: Update Package.json Scripts

Update your `package.json` with these scripts:
```json
{
  "scripts": {
    "dev": "next dev",
    "build:api": "node scripts/generate-api.js",
    "build": "npm run build:api && next build",
    "start": "next start",
    "deploy": "vercel --prod"
  }
}
```

### Step 8: Test Locally

```bash
# Generate API files
npm run build:api

# Check output
ls public/api/notes/     # Should see first-note.md
cat public/api/files.json  # Should see note metadata

# Start dev server
npm run dev

# Visit http://localhost:3000
# Visit http://localhost:3000/api/metadata.json
# Visit http://localhost:3000/api/files.json
# Visit http://localhost:3000/api/notes/first-note.md
```

### Step 9: Initial Deployment to Vercel

**Option A: Using Vercel CLI (Recommended)**
```bash
# Install Vercel CLI if not already installed
npm i -g vercel

# Login to Vercel
vercel login

# Deploy to production
vercel --prod

# Follow prompts:
# - Set up and deploy? Yes
# - Which scope? (Your account)
# - Link to existing project? No
# - Project name: my-dev-notes-blog
# - Directory: ./
# - Override settings? No

# After deploy, note the production URL:
# https://my-dev-notes-blog.vercel.app
```

**Option B: Using GitHub Integration (Recommended for Auto-Deploy)**
1. Push your code to GitHub
2. Go to [vercel.com](https://vercel.com) and import your repository
3. Vercel will auto-detect Next.js settings
4. Click "Deploy"
5. Every future push to main branch will auto-deploy

**Important:** Vercel automatically sets `VERCEL_URL` environment variable during build, which the build script uses to generate correct URLs in `files.json`.

### Step 10: Update Metadata URL (One-Time Setup)

After first deployment, update `public/api/metadata.json` with your actual Vercel domain:

```json
"fileList": {
  "url": "https://my-dev-notes-blog.vercel.app/api/files.json",
  "format": "json",
  "lastUpdated": "2025-11-08T00:00:00Z"
}
```

Commit and push (or redeploy):
```bash
git add public/api/metadata.json
git commit -m "Update metadata with production URL"
git push  # Auto-deploys if using GitHub integration

# OR manually deploy:
vercel --prod
```

**Note:** After this one-time setup, the build script will automatically derive the base URL from this metadata file, so you won't need to update it again.

### Step 11: Verify Endpoints

Test all three endpoints in your browser:
```
https://my-dev-notes-blog.vercel.app/api/metadata.json
https://my-dev-notes-blog.vercel.app/api/files.json
https://my-dev-notes-blog.vercel.app/api/notes/first-note.md
```

All should return properly formatted content with correct CORS headers.

### Step 12: Share Your Metadata URL

Share in the event chat or community registry:
```
https://my-dev-notes-blog.vercel.app/api/metadata.json
```

### Step 13: Keep Publishing

Write 4 more notes (5 total minimum) as you build during Hackathon. Each time:

```bash
# 1. Create new file in content/notes/my-second-note.md
# 2. Add frontmatter and content
# 3. Commit and push (triggers auto-deploy)
git add .
git commit -m "Add note: my-second-note"
git push

# That's it! Vercel auto-deploys and runs build:api script
# Your new note is live in ~60 seconds
```

**No manual build step needed** - the Vercel build process runs `npm run build:api && next build` automatically.

---

## Quick Start Checklist

### Phase 1: Get Your Blog Running

- [ ] Choose tech stack (Next.js or Plain HTML)
- [ ] Set up project structure with `public/api/` directory
- [ ] Create `public/api/metadata.json` with your profile
- [ ] Write your first note in `content/notes/`
- [ ] Create `scripts/generate-api.js` build script
- [ ] Test endpoints locally
- [ ] Deploy to Vercel
- [ ] Share your metadata URL: `https://yourdomain.vercel.app/api/metadata.json`
- [ ] Publish 4 more notes (5 total minimum)

### Phase 2: Build the Aggregator

- [ ] Create Next.js or React project
- [ ] Create `public/registry.json` with developer URLs
- [ ] Build metadata fetcher
- [ ] Build notes aggregator
- [ ] Create feed view UI
- [ ] Add filtering/search
- [ ] Deploy or run locally
- [ ] Share with community

---

## Troubleshooting

### Endpoint Returns 404
**Problem:** `/api/metadata.json` or `/api/files.json` returns 404

**Solutions:**
- Ensure files exist in `public/api/` directory
- For Vercel: Check build completed successfully
- Verify URL matches your deployment domain
- Check `vercel.json` is in project root

### Build Script Fails
**Problem:** `npm run build:api` throws errors

**Solutions:**
- Install dependencies: `npm install gray-matter`
- Ensure `content/notes/` directory exists
- Check all `.md` files have valid frontmatter
- Verify frontmatter has required fields: `title` and `date`

### CORS Errors in Phase 2 Client
**Problem:** Client can't fetch from blog endpoints

**Solutions:**
- Add `vercel.json` with CORS headers (see Vercel Configuration section)
- Redeploy after adding `vercel.json`
- Test endpoints directly in browser first
- Check browser console for specific CORS error

### Notes Not Showing in files.json
**Problem:** New note not appearing in generated list

**Solutions:**
- Run `npm run build:api` after creating note
- Check note has `.md` extension
- Verify frontmatter is valid YAML (correct indentation)
- Ensure `date` field is ISO 8601 format: `"2025-11-08T10:00:00Z"`

### Vercel Build Fails
**Problem:** Deployment fails on Vercel

**Solutions:**
- Set build command: `npm run build:api && next build`
- Check all dependencies in `package.json`
- Verify Node.js version (use 18+)
- Check build logs for specific error

### Markdown Not Rendering
**Problem:** Note content shows raw markdown

**Solutions:**
- Install markdown parser: `npm install markdown-it`
- Implement markdown rendering in note detail page
- Use `gray-matter` to separate frontmatter from content
- Parse content with markdown library before displaying

---

## Future Considerations

- Integration with RbR website
- RSS/Atom feed support
- Notification system for new notes
- Markdown extensions (syntax highlighting, diagrams)
- Archive/backup functionality
- Community moderation tools
- Web3/decentralized storage options
